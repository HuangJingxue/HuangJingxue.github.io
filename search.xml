<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>豆瓣电影排行榜</title>
    <url>/undefined/9836.html</url>
    <content><![CDATA[<h1 id="1-如何处理数据"><a href="#1-如何处理数据" class="headerlink" title="1.如何处理数据"></a>1.如何处理数据</h1><p>BeautifulSoup</p>
<ul>
<li>解析数据</li>
<li>提出数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h1><h2 id="2-1获取豆瓣图书TOP250当中"><a href="#2-1获取豆瓣图书TOP250当中" class="headerlink" title="2.1获取豆瓣图书TOP250当中"></a>2.1获取豆瓣图书TOP250当中</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 引入 BeautifulSoup</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(<span class="string">'https://book.douban.com/top250'</span>, headers=headers)</span><br><span class="line"><span class="comment"># 第一个参数为网页源代码，第二个参数为解析器</span></span><br><span class="line">soup = BeautifulSoup(res.text, <span class="string">'html.parser'</span>)</span><br><span class="line"><span class="comment"># print(soup)</span></span><br><span class="line"><span class="comment"># items = soup.find_all('div', class_='pl2')</span></span><br><span class="line">items = soup.select(<span class="string">'div.pl2 a'</span>)</span><br><span class="line"><span class="comment"># print(items)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">  <span class="comment"># tag = i.find('a')</span></span><br><span class="line">  <span class="comment"># name = ''.join(tag.text.split())</span></span><br><span class="line">  <span class="comment"># name = tag['title']</span></span><br><span class="line">  <span class="comment"># link = tag['href']</span></span><br><span class="line">  name = i[<span class="string">'title'</span>]</span><br><span class="line">  link = i[<span class="string">'href'</span>]</span><br><span class="line">  print(name, link)</span><br></pre></td></tr></table></figure>

<h2 id="2-2获取豆瓣电影的数据-电影名和链接"><a href="#2-2获取豆瓣电影的数据-电影名和链接" class="headerlink" title="2.2获取豆瓣电影的数据(电影名和链接)"></a>2.2获取豆瓣电影的数据(电影名和链接)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">'https://movie.douban.com/top250'</span>, headers=headers)</span><br><span class="line">soup = BeautifulSoup(res.text,<span class="string">'html.parser'</span>)</span><br><span class="line"></span><br><span class="line">items = soup.select(<span class="string">'div.hd a'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">  link = i[<span class="string">'href'</span>]</span><br><span class="line">  tag = i.find(class_=<span class="string">'title'</span>)</span><br><span class="line">  name = tag.text</span><br><span class="line">  print(name,link)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发语言</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据开发</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫初体验</title>
    <url>/undefined/5208.html</url>
    <content><![CDATA[<h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res = requests.get(<span class="string">'https://wpblog.x0y1.com'</span>)</span><br><span class="line"><span class="comment">#print(res)</span></span><br><span class="line">print(res.text)</span><br><span class="line"><span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">  print(<span class="string">'请求成功'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'请求失败'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取孔乙己数据</span></span><br><span class="line">res = requests.get(<span class="string">'https://apiv3.shanbay.com/codetime/articles/mnvdu'</span>)</span><br><span class="line"><span class="comment"># 以写入的方式打开一个名为孔乙己的 txt 文档</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'孔乙己.txt'</span>, <span class="string">'w'</span> ,encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">  <span class="comment"># 将数据的字符串形式写入文件中</span></span><br><span class="line">  file.write(res.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取图片数据</span></span><br><span class="line">res = requests.get(<span class="string">'https://assets.baydn.com/baydn/public/codetime/xiaobei/info.jpg'</span>)</span><br><span class="line"><span class="comment"># 以二进制写入的方式打开一个名为 info.jpg 的文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'info.jpg'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line"><span class="comment"># 将数据的二进制形式写入文件中</span></span><br><span class="line">  file.write(res.content)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>变量 <strong>res</strong>它的类型是 <strong>Response</strong> 对象</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>res.status_code</td>
<td>响应的 HTTP 状态码</td>
</tr>
<tr>
<td>res.text</td>
<td>响应内容的字符串形式</td>
</tr>
<tr>
<td>res.content</td>
<td>响应内容的二进制形式</td>
</tr>
<tr>
<td>res.encoding</td>
<td>响应内容的编码</td>
</tr>
</tbody></table>
<h2 id="爬虫初体验"><a href="#爬虫初体验" class="headerlink" title="爬虫初体验"></a>爬虫初体验</h2><blockquote>
<p>目标：自动循环小王子的所有章节，将故事存放到一个目录当中，每个章节一份文件。title做为文件名</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">'http://www.eywedu.net/xiaowangzi/14.htm'</span>)</span><br><span class="line">res.encoding=<span class="string">'gb2312'</span></span><br><span class="line">text = res.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open (<span class="string">'小王子.txt'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">  file.write(text)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据开发</tag>
      </tags>
  </entry>
  <entry>
    <title>MonogDB初体验</title>
    <url>/undefined/15869.html</url>
    <content><![CDATA[<h1 id="1-MonogDB简介"><a href="#1-MonogDB简介" class="headerlink" title="1.MonogDB简介"></a>1.MonogDB简介</h1><p>MongoDB 是一款强大，灵活，且易于扩展的通用性数据库，<strong>面向文档的数据库</strong>。</p>
<ul>
<li>二级索引</li>
<li>范围查询</li>
<li>排序</li>
<li>聚合</li>
<li>地理空间索引</li>
</ul>
<a id="more"></a>

<p>丰富的功能：</p>
<ul>
<li>索引（indexing）</li>
</ul>
<p>MongoDB支持通用二级索引，允许多种快速查询，且提供唯一索引、复合索引、地理空间索引，以及全文索引。</p>
<ul>
<li>聚合（aggregation）</li>
</ul>
<p>MongoDB支持“聚合管道”。用户能通过简单的片段创建复杂的聚合，并通过数据库自动优化。</p>
<ul>
<li>特殊的集合类型</li>
</ul>
<p>MongoDB支持存在时间有限的集合，适用于那些将在某个时刻过期的数据，如会话。固定大小的集合，用于保存近期数据，如日志。</p>
<ul>
<li>文件存储</li>
</ul>
<p>MongoDB支持一种非常医用的协议，用于存储大文件和文件元数据。</p>
<p>基本概念：</p>
<ul>
<li>文档是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具有表现力。</li>
<li>集合是一个拥有动态模式的表。</li>
<li>MongoDB的一个实例可以拥有多个相互独立的数据库，每一个数据库都拥有自己的集合。</li>
<li>每一个文档都有一个特殊的键“_id”,这个键在文档所属的集合中是唯一的。</li>
<li>MongoDB自带了一个简单但功能强大的JavaScript shell，可用于管理MongoDB的实例或数据操作。</li>
</ul>
<h1 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2.基础知识"></a>2.基础知识</h1><p>集合命名：</p>
<ul>
<li>集合名不能使空字符串（””）</li>
<li>集合名不能包含\0字符（空字符），这个字符表示集合名的结束。</li>
<li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li>
<li>用户创建的集合不能在集合名中包含保留字符’$’。</li>
</ul>
<p>子集合：</p>
<p>组合集合的一种惯例是使用“.”分隔不同命名空间的子集合。</p>
<ul>
<li>GridFS使用自己和来存储文件的元数据，这样就可以与文件内容块很好地隔离开来。</li>
<li>大多数驱动程序都提供了一些语法糖，用于访问指定集合的子集合。</li>
</ul>
<p>数据库：</p>
<ul>
<li>多个文档组成集合，多个集合可以组成数据库。</li>
<li>一个MongoDB实例可以承载多个数据库，每个数据库拥有0个或者多个集合。</li>
<li>每个数据库斗殴独立的权限，即便是在磁盘上，不同的数据库也放置在不同的文件中。</li>
</ul>
<p>数据库命名：</p>
<ul>
<li>不能空字符串（””）</li>
<li>基本只能使用ASCII中的字母和数字。</li>
<li>数据库名区分大小写（不区分大小写的文件系统也是如此，建议全部小写）。</li>
<li>数据库名最多为64字节。</li>
</ul>
<h1 id="3-启动关闭MongoDB"><a href="#3-启动关闭MongoDB" class="headerlink" title="3.启动关闭MongoDB"></a>3.启动关闭MongoDB</h1><ul>
<li>mongod默认数据目录/data/db（Windows系统中为C:\data\db）。</li>
<li>启动前，创建数据目录（mkdir -p /data/db）,确保对改目录有写权限。</li>
<li>默认MonoDB监听27017端口。</li>
</ul>
<h1 id="4-MonogDB客户端"><a href="#4-MonogDB客户端" class="headerlink" title="4.MonogDB客户端"></a>4.MonogDB客户端</h1><ul>
<li>启动时，mongodb shell会练到MongoDB服务器的test数据库，并将数据库连接赋值给全局变量db。</li>
<li>这个变量是通过shell访问MongoDB的主要入口点。</li>
</ul>
<h1 id="5-shell中的基本操作"><a href="#5-shell中的基本操作" class="headerlink" title="5.shell中的基本操作"></a>5.shell中的基本操作</h1><p>1、创建</p>
<ul>
<li>insert函数可将一个文档添加到集合中。</li>
<li>创建一个名为post的局部变量，用来表示我们的文档。</li>
<li>它会有几个键：”title”、”content”、“date”。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; post &#x3D; &#123;&quot;title&quot;:&quot;this is test,&quot;&#125;</span><br><span class="line">&#123; &quot;title&quot; : &quot;this is test,&quot; &#125;</span><br><span class="line">&gt; post &#x3D; &#123;&quot;title&quot;:&quot;this is test&quot;,</span><br><span class="line">... &quot;content&quot; :&quot;here&#39;s my blog test&quot;,</span><br><span class="line">... &quot;data&quot;:new Date()&#125;</span><br><span class="line">&#123;</span><br><span class="line">	&quot;title&quot; : &quot;this is test&quot;,</span><br><span class="line">	&quot;content&quot; : &quot;here&#39;s my blog test&quot;,</span><br><span class="line">	&quot;data&quot; : ISODate(&quot;2017-10-12T03:20:09.121Z&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&gt; show dbs</span><br><span class="line">local  0.000GB</span><br><span class="line">&gt; use hjxdb</span><br><span class="line">switched to db hjxdb</span><br><span class="line">&gt; db.blog.insert(post);</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line">&gt; db.blog.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59dedf7ecb7cf32013d3da35&quot;), &quot;title&quot; : &quot;this is test&quot;, &quot;content&quot; : &quot;here&#39;s my blog test&quot;, &quot;data&quot; : ISODate(&quot;2017-10-12T03:20:09.121Z&quot;) &#125;</span><br></pre></td></tr></table></figure>

<p>2、读取</p>
<p>find和findOne方法可以用于查询集合里的文档。若只想查看一个文档，可用findOne：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.blog.findOne()</span><br><span class="line">&#123;</span><br><span class="line">	&quot;_id&quot; : ObjectId(&quot;59dedf7ecb7cf32013d3da35&quot;),</span><br><span class="line">	&quot;title&quot; : &quot;this is test&quot;,</span><br><span class="line">	&quot;content&quot; : &quot;here&#39;s my blog test&quot;,</span><br><span class="line">	&quot;data&quot; : ISODate(&quot;2017-10-12T03:20:09.121Z&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、更新</p>
<ul>
<li>update至少两个参数</li>
<li>一个是限定条件,匹配待更新的文档</li>
<li>一个是新的文档</li>
<li>之前的文章增加平冷功能，新增一个键，用来保存评论数组</li>
</ul>
<p>增加”comments”键：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; post.comments &#x3D; []</span><br><span class="line">[ ]</span><br><span class="line">&gt; db.blog.update(&#123;title:&quot;this is test&quot;&#125;,post)</span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br><span class="line">&gt; db.blog.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59dedf7ecb7cf32013d3da35&quot;), &quot;title&quot; : &quot;this is test&quot;, &quot;content&quot; : &quot;here&#39;s my blog test&quot;, &quot;data&quot; : ISODate(&quot;2017-10-12T03:20:09.121Z&quot;), &quot;comments&quot; : [ ] &#125;</span><br></pre></td></tr></table></figure>

<p>4、删除</p>
<ul>
<li>remove方法可将文档从数据库中永久删除。</li>
<li>没有任何参数，将删除集合内的所有文档全部删除。</li>
<li>接受一个限定条件的文档作为参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.blog.remove(&#123;title:&quot;this is test&quot;&#125;)</span><br><span class="line">WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;)</span><br><span class="line">&gt; db.blog.find()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql误删数据谁来背锅</title>
    <url>/undefined/d4c410ce.html</url>
    <content><![CDATA[<blockquote>
<p>我们不止要说误删数据的事后处理办法，更重要是要做到事前预防。</p>
</blockquote>
<p><em>误删数据分类</em></p>
<ul>
<li>使用 delete 语句误删数据行；</li>
<li>使用 drop table 或者 truncate table 语句误删数据表；</li>
<li>使用 drop database 语句误删数据库；</li>
<li>使用 rm 命令误删整个 MySQL 实例。<a id="more"></a>

</li>
</ul>
<p><em>需要完善自动恢复脚本</em></p>
<blockquote>
<p>一种加速的方法是，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.恢复全量备份</span></span><br><span class="line">a.指定全量备份路径</span><br><span class="line">b.写入全量备份名称</span><br><span class="line">c.恢复全量备份到指定临时实例</span><br><span class="line"></span><br><span class="line">在 start slave 之前，先通过执行﻿﻿change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表；</span><br><span class="line">这样做也可以用上并行复制技术，来加速整个数据恢复过程。</span><br><span class="line"><span class="comment">#2.自动恢复binlog</span></span><br><span class="line">a.指定binlog备份路径</span><br><span class="line">b.指定需要恢复的binlog名称（1个或者多个）</span><br><span class="line">c.恢复binlog到指定临时实例</span><br></pre></td></tr></table></figure>

<p><em>预防误删库 / 表的方法</em></p>
<ul>
<li><p>第一条建议是，账号分离。这样做的目的是，避免写错命令。</p>
<blockquote>
<p>比如：我们只给业务开发同学 DML 权限，而不给 truncate/drop 权限。<br>而如果业务开发人员有 DDL 需求的话，也可以通过开发管理系统得到支持。<br>即使是 DBA 团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</p>
</blockquote>
</li>
<li><p>第二条建议是，制定操作规范。</p>
<blockquote>
<p>这样做的目的，是避免写错要删除的表名。<br>比如：在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。<br>改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么你改了我看不见?</title>
    <url>/undefined/c0a85e31.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>启动事务；查询得到值</td>
<td>启动事务</td>
</tr>
<tr>
<td></td>
<td>查询得到值1</td>
</tr>
<tr>
<td></td>
<td>将1改成2</td>
</tr>
<tr>
<td>查询得到值V1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>提交事务B</td>
</tr>
<tr>
<td>查询得到值V2</td>
<td></td>
</tr>
<tr>
<td>提交事务A</td>
<td></td>
</tr>
<tr>
<td>查询得到值V3</td>
<td></td>
</tr>
</tbody></table>
<p>若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以，V3的值也是2。</p>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p>
<ul>
<li>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li>
<li>在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。</li>
<li>在“读未提交”隔离级别下直接返回记录下的最新之，没有视图概念。</li>
<li>而“串性化”隔离级别下直接用加锁的方式来避免并行访问。</li>
</ul>
<p>为保证数据库隔离级别一致，你一定要记得将MYSQL的隔离级别设置为“读提交”。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
